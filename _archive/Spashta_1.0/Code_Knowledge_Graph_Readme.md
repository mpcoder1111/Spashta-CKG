# Code Knowledge Graph (CKG) Protocol

## 1. Philosophy: The "Dual-Brain" Architecture
To prevent the common problem where AI Agents hallucinate code structure or miss-understand architectural intent, we use a two-stage Knowledge Graph.

*   **Stage 1: The Body (Objective Truth)**
    *   **Source**: Generated programmatically by `build_kg_ast_based.py`.
    *   **Content**: Syntax, File Paths, Classes, Functions, Imports, Calls.
    *   **Nature**: 100% Accurate, deterministic, structure-only.
    *   **File**: `code_knowledge_graph_AST_based.json`

*   **Stage 2: The Mind (Semantic Truth)**
    *   **Source**: Generated by the **AI Agent** (You) during the "Enrichment" phase.
    *   **Content**: "Why this exists", "Architectural Layer", "Responsibility Scope", "Business Logic vs Boilerplate".
    *   **Nature**: Intellectual, context-aware, intent-driven.
    *   **File**: `code_knowledge_graph_AST_Enriched_by_AI.json`

---

## 2. The JSON Schema
All Agents must output strictly to this Schema.

```json
{
  "app_name": "Project_Name",
  "_comment_app_name": "Logical app name for scoping queries.",
  "generated_by": "build_kg_ast_based.py v1.3",
  "_comment_generated_by": "Tracks tool version to manage schema drift.",
  "files": [
    {
      "node_type": "File",
      "_comment_node_type": "Explicit typing prevents semantic guessing.",
      "filename": "name_of_file.py",
      "path": "path/to/file.py",
      "_comment_path": "Absolute or relative path to allow direct file access.",
      "file_hash": "md5_hash_of_content",
      "_comment_file_hash": "MD5 checksum for incremental update detection.",
      "analysis_confidence": "structural_only | fully_enriched",
      "_comment_analysis_confidence": "Indicates if node needs AI Agent review.",
      "layer": "UI | Application | Service | Domain | Infrastructure",
      "_comment_layer": "Initial AST layer is a HINT. Agent must override if incorrect.",
      "framework_bound": true, 
      "_comment_framework_bound": "True if code is coupled to framework (e.g. Django/Streamlit) and hard to reuse.",
      "purpose": "High-level summary of what this file does.",
      "why_developed": "The architectural reason for its existence.",
      "responsibility_scope": "What it is allowed to do (and NOT do).",
      "pure_logic": false, 
      "_comment_pure_logic": "True if function/file has NO side effects (IO/State). AST default is PROVISIONAL and must be verified by Agent.",
      "public_contract": {
        "inputs": ["list", "of", "arguments"],
        "outputs": ["return", "values"],
        "guarantees": ["no_side_effects", "thread_safe"]
      },
      "edges": {
        "imports": ["list.of.modules"],
        "calls": ["module.Class.method"],
        "_comment_calls": "Approximation only (Stage 1). Resolving complex chains requires dynamic analysis.",
        "uses_state": ["global:CACHE_VAR", "session:user_id"],
        "_comment_uses_state": "Explicitly defined scope: 'global', 'session', or 'request'.",
        "reads_from": ["files", "dbs"],
        "writes_to": ["files", "dbs"],
        "side_effects": true
      },
      "classes": [
        {
          "node_type": "Class",
          "name": "ClassName",
          "purpose": "Why this class exists.",
          "pure_logic": true,
          "edges": { "calls": ["..."], "side_effects": false },
          "key_methods": [
            {
              "node_type": "Function",
              "name": "method_name",
              "purpose": "What this method achieves.",
              "pure_logic": true
            }
          ]
        }
      ],
      "functions": [
         {
          "node_type": "Function",
          "name": "top_level_func",
          "purpose": "Purpose of this standalone function.",
          "pure_logic": true,
          "edges": { "calls": ["..."], "side_effects": false }
        }
      ]
    }
  ]
}
```

---

## 3. Agent Protocol

### Rule 1: The "Look First" Policy
Before reading any source code to answer a user question, the Agent **MUST** read `code_knowledge_graph_AST_Enriched_by_AI.json`.
*   *Why?* It provides the "Map" of the territory. It tells you where the logic lives (Backend vs UI).

### Rule 2: The "Enrichment" Duty
If `code_knowledge_graph_AST_Enriched_by_AI.json` is missing or the User says "I have added new feature X", the Agent must:
1.  Run `python Spashta-CKG/build_kg_ast_based.py` (Re-scans structure).
2.  Read the new `code_knowledge_graph_AST_based.json`.
3.  **Think**: Analyze the new structure (checking `classes` AND `functions` lists).
4.  **Write**: Generate/Update `code_knowledge_graph_AST_Enriched_by_AI.json` with semantic details.
    *   **CRITICAL**: You MUST update `analysis_confidence` from `"structural_only"` to `"fully_enriched"` after verifying the node. This is your "Digital Signature" of review.

### Rule 3: Handling Drift
The Agent acts as the "Gardener".
*   If you see a file in the code that is NOT in the CKG, assume the CKG is stale.
*   **Action**: Re-run the generation process (Rule 2).
*   **Verify**: Check `Spashta-CKG/build_kg_ast_based.py` -> `IGNORE_DIRS` list. Ensure strictly that valid code is not being ignored.

### Rule 4: User Role in Maintenance
The USER is the "Director".
*   The User will trigger the initial build or major refactors.
*   The User expects the Agent to *proactively* suggest updates if the Agent notices the code and KG are out of sync during a task.
*   **Command**: "Agent, sync the CKG" -> Triggers Rule 2.

### Rule 5: Querying Mechanics
Agents should **programmatically query** the JSON data rather than asking vague natural language questions about it.
*   *Bad*: "What files handle data?"
*   *Good*: `[f['filename'] for f in kg['files'] if 'pandas' in f['edges']['imports']]`
*   **Reasoning**: This ensures deterministic, instant, and accurate answers using the specific node attributes (`pure_logic`, `layer`, `edges`).

### Rule 6: Incremental Updates via Hashing
The CKG uses `file_hash` (MD5) to track file states.
*   **Verification**: Before enriching a file, the Agent should calculate the current MD5 hash of the file and compare it with the `file_hash` in `AST_based.json`.
*   **Match**: If hashes match, the file has **NOT** changed. The Agent can skip re-reading the file content and trust the existing "Enriched" data.
*   **Mismatch**: If hashes differ, the Agent **MUST** read the file content, re-analyze it, and update the specific node in the Enriched JSON.
*   **Optimization**: This allows for precise, rapid updates without re-scanning the entire codebase.

---

## 4. Directory Structure
```text
Project_Root/
├── Spashta-CKG/
│   ├── build_kg_ast_based.py        # The Structural Scanner (Objective Truth)
│   ├── Code_Knowledge_Graph_Readme.md # THIS FILE (The Protocol & Schema)
│   ├── code_knowledge_graph_AST_based.json # Raw Output
│   └── code_knowledge_graph_AST_Enriched_by_AI.json # Final "Refined Mind"
├── src/
│   └── ... application code ...
└── ...
```

---

## 5. Universal Applicability & Limitations

### Why the Schema is Universal
This protocol is designed to be **Language-Agnostic**. It models universal software engineering concepts:
*   **Nodes**: `File`, `Class`, `Function` exist in almost all modern languages (Java, TS, C#, Go).
*   **Layers**: `UI`, `Service`, `Application`, `Domain`, `Infrastructure` are standard architectural patterns.
*   **Edges**: `imports` (dependencies), `calls` (execution flow), and `I/O` are fundamental to all computing.

### Current Implementation Scope
*   **Python**: Fully supported and automated via `build_kg_ast_based.py`. It solves Python-based architectural analysis "out of the box", handling imports, classes, and function definitions via AST.
*   **Other Languages**: The *Schema* (JSON structure) remains valid and recommended for any project, but you would need to write a specific builder (e.g., `build_kg_ts.ts` for TypeScript) to generate the initial structure.

### Limitations & Heuristics (Important)
1.  **Stage 1 Precision**: The Call Graph in `AST_based.json` is **approximate**. It captures `obj.method` but cannot resolve complex inheritance or dynamic dispatch without running the code.
2.  **Layer Heuristics**: The `layer` assigned by `build_kg_ast_based.py` is a regex-based **hint**. The AI Agent is the authoritative source for the true architectural layer during Enrichment.
3.  **Non-OO Languages**: Concepts like "Class" may not map directly to SQL, HTML, or CSS.

## 6. Future Roadmap
*   **`kg_query.py`**: A helper library for common graph queries (e.g., "Find all pure functions in the Service layer"). Currently, Agents perform these queries ad-hoc.
*   **Component-Level Hashing**: Extending the `file_hash` concept to individual functions for even more granular incremental updates.
