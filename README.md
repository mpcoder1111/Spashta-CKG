# Spashta-CKG: The Code Knowledge Graph for Agentic Coding

**Spashta-CKG** is a lightweight, standardized architecture designed to give AI Coding Agents "Situational Awareness" of your codebase.

It solves the "Lost in the Woods" problem where AI agents hallucinate file paths, misunderstand architecture, or break existing logic because they lack a structured map of the project.

> **Note:** Currently, Spashta-CKG is optimized primarily for **Python** projects developed using **Agentic IDEs**.

## üöÄ Why Spashta-CKG?

Most AI coding tools rely on RAG (Vector Search) or raw file reading‚Äîmethods that are often probabilistic or resource-expensive (wasting token limits). Spashta-CKG introduces a **Deterministic Architectural Memory**:

*   **Dual-Brain Architecture**:
    *   **Stage 1 (Body)**: 100% Accurate Abstract Syntax Tree (AST)-based structure (generated by the tool).
    *   **Stage 2 (Mind)**: Semantic Understanding (enriched by the Agent).
*   **Hash-Based Updates**: Only re-analyze changed files.
*   **Hallucination Guardrails**: Agents query facts, they don't guess them.



## üì¶ What's Included?

This repository contains the core specification and the reference implementation:

1.  **The Tool**: `build_kg_ast_based.py` - A zero-dependency Python script to generate the AST Knowledge Graph.
2.  **The Protocol**: `Code_Knowledge_Graph_Readme.md` - The schema and rules agents must follow.
3.  **The Proof**: `Agent_Validation_Impact_Analysis.txt` - Real-world transcript of an Agent using CKG to analyze impact without reading code.

## üõ†Ô∏è Quick Start

1.  **Copy** the `Spashta-CKG` folder into your project root.
2.  **Run** the builder script:
    ```bash
    python Spashta-CKG/build_kg_ast_based.py
    ```
3.  **Result**: It generates `code_knowledge_graph_AST_based.json`.
4.  **Enrich (First Run)**: Provide the following prompt to your AI Agent (Antigravity, Cursor, Windsurf, etc.) to start using it:
    
    ```prompt
    Hello. This project follows a Code Knowledge Graph (CKG)‚Äìbased architecture.

    1. First, read `Spashta-CKG/Code_Knowledge_Graph_Readme.md` to understand the architecture and rules.
    2. Check whether `Spashta-CKG/code_knowledge_graph_AST_based.json` exists.
       - If it does NOT exist, run: `python Spashta-CKG/build_kg_ast_based.py` to generate it.
    3. Check whether `Spashta-CKG/code_knowledge_graph_AST_Enriched_by_AI.json` exists.
       - If it exists, load it to understand the codebase.
       - If it does NOT exist, analyze the codebase as described in the README and create a new file named `code_knowledge_graph_AST_Enriched_by_AI.json` in the `Spashta-CKG/` folder with the required fields.

    After completing the above steps, explain the project architecture.  
    Acknowledge when you are ready; I will then provide the specific coding task.
    ```

5.  **Enrich (Updates)**: If code changes, ask the Agent to update the graph:
    ```prompt
    Hello. Update the Enriched JSON `Spashta-CKG/code_knowledge_graph_AST_Enriched_by_AI.json` as per the rules mentioned in `Spashta-CKG/Code_Knowledge_Graph_Readme.md`.
    ```

## üìö Documentation

*   [Technical Manual & Schema](./Code_Knowledge_Graph_Readme.md)
*   [Success Story / Case Study](./docs/Agent_Validation_Impact_Analysis.txt)

## üß† How Spashta-CKG Architecture helps in Agentic Code Building

### Overview
Modern software development is increasingly augmented by Large Language Models (LLMs) acting as coding agents. While these agents are powerful, they suffer from well-known limitations: finite context windows, token cost, and hallucinations when architectural intent is unclear. 

The **Code Knowledge Graph (CKG)** directly addresses these challenges by introducing a structured, deterministic, and continuously maintained architectural memory. It serves as a "shared brain" for both human developers and AI agents, ensuring that architectural intent is explicit, machine-readable, and enforceable.

---

## Key Benefits

### 1. Provides Clear Context for AI
**The Problem:** AI agents typically struggle to understand the "big picture" without reading every single file, which consumes context and tokens.  
**The Solution:** The CKG provides a structural map of the codebase. Agents instantly know where files are located, what each file is responsible for, and how the system is organized without needing to parse the entire source code.

### 2. Drastically Reduces Hallucinations
**The Problem:** When an AI guesses about dependencies or matching function signatures, it often "hallucinates" code that doesn't exist.  
**The Solution:** By relying on the CKG's structured facts (imports, class definitions, and function signatures), agents query **objective truth** instead of inferring probabilities. This turns architectural assumptions into verified lookups.

### 3. Lowers Cognitive Burden
**The Problem:** Both humans and AIs waste energy re-learning why a piece of code was written or how it fits into the broader system.  
**The Solution:** Architecture and design intent are stored once in the "Enriched" layer of the Knowledge Graph. Humans and agents can query this intent on-demand, freeing up cognitive resources for solving new problems rather than understanding old ones.

### 4. Saves Time and Operational Costs
**The Problem:** Re-analyzing a large codebase for every prompt is slow and expensive (token-wise).  
**The Solution:** The CKG uses **MD5 file hashing** to track changes. Only files that have structurally changed are re-processed. This incremental approach minimizes token usage and speeds up agent response times.

### 5. Enables Safer Code Changes
**The Problem:** "Fixing" one part of the code often breaks another due to hidden dependencies.  
**The Solution:** The CKG explicitly maps dependencies (imports, calls, and usage). Agents can perform **impact analysis** before writing a single line of code, ensuring that refactoring is safe and side-effects are known.

### 6. Prevents Architectural Drift
**The Problem:** Over time, codebases tend to become "spaghetti code" as layer boundaries (e.g., UI vs. Backend) are violated.  
**The Solution:** The CKG enforces explicit architectural layers (e.g., `UI`, `Service`, `Infrastructure`) and purity rules. Agents are guided to place code in the correct layer, preserving the integrity of the design system.

### 7. Lightweight and Simple
**The Benefit:** Unlike complex enterprise architecture tools, Spashta-CKG requires no database servers or heavy infrastructure. It runs using **standard Python** and outputs **human-readable JSON**. It integrates seamlessly into existing workflows.

## üìÑ License

Apache 2.0 - Free for personal and commercial use.

---
*Created by mpcoder1111*
