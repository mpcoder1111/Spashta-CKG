# Spashta-CKG: Universal Architecture Reference

> **Audience**: Contributors, developers, AI agents, and anyone seeking to understand Spashta's architecture deeply.
>
> **Purpose**: This is the **authoritative architectural reference** for Spashta-CKG 2.0. It explains *why* the system is designed this way and *how* each component works together.

*Last Updated: 2025-12-30*

---

## Table of Contents

1. [Why Spashta-CKG Exists](#1-why-spashta-ckg-exists)
2. [Core Philosophy](#2-core-philosophy)
3. [Architecture Overview](#3-architecture-overview)
4. [Layer 1: Core (Universal Laws)](#4-layer-1-core-universal-laws)
5. [Layer 2: Builders (Language Observers)](#5-layer-2-builders-language-observers)
6. [Layer 3: Adapters (Framework Interpreters)](#6-layer-3-adapters-framework-interpreters)
7. [Layer 4: Runtime (Execution Engine)](#7-layer-4-runtime-execution-engine)
8. [Layer 5: Project (Declaration Layer)](#8-layer-5-project-declaration-layer)
9. [Enrichment Levels](#9-enrichment-levels)
10. [Agent Workflow](#10-agent-workflow)
11. [Extensibility Guide](#11-extensibility-guide)
12. [File Modification Rules](#12-file-modification-rules)
13. [Mental Anchors](#13-mental-anchors)

---

## 1. Why Spashta-CKG Exists

Modern AI coding agents struggle with large, real-world codebases because:

| Problem | Impact |
|---------|--------|
| **Context windows are limited** | Agents can't read entire codebases |
| **Agents hallucinate** | Agents may invent file paths, functions, or architecture that don't exist |
| **Framework migrations break understanding** | Moving from Streamlit ‚Üí Django confuses agents |
| **Re-reading codebases is costly** | Wastes tokens and time |

Spashta-CKG addresses this by introducing **Deterministic Architectural Memory** ‚Äî a structured, machine-readable understanding of a codebase that both humans and agents can rely on.

> **Core Idea:** Agents should *query facts*, not *guess structure*.

---

## 2. Core Philosophy

Spashta-CKG is built on three fundamental principles:

### 2.1 Structure Before Semantics

> **Do not try to understand meaning before knowing structure.**

| Layer | Question Answered | Generated By |
|-------|-------------------|--------------|
| **Structure** | *What exists?* | Builders (programmatic, 100% accurate) |
| **Semantics** | *What does it mean?* | Adapters + LLM (layered enrichment) |

In Spashta terms:
- **AST JSON = Structure (Objective Truth)** ‚Äî Files, functions, classes, imports, calls
- **Enriched JSON = Semantics (Contextual Understanding)** ‚Äî Purpose, roles, boundaries

### 2.2 Rules Over Prose

Traditional documentation is written for humans. AI agents skip sections, forget rules, and interpret prose inconsistently.

Spashta replaces prose with **machine-enforceable rules**:

| Approach | Example |
|----------|---------|
| ‚ùå Prose | "Templates should not contain business logic" |
| ‚úÖ Rule | Detection patterns in `framework_mapping.json` |

### 2.3 Universality (Surviving Change)

Languages change. Frameworks change. Even AI agents change. What should *not* change is the **mental model of software itself**.

This is achieved by strict separation:

| Layer | Purpose | Example |
|-------|---------|---------|
| **Core** | Universal concepts | File, Function, Class, Template |
| **Builders** | Language structure | Python ‚Üí Function node |
| **Adapters** | Framework meaning | Django ‚Üí View semantic role |

---

## 3. Architecture Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                              SPASHTA-CKG 2.0                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                             ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ   ‚îÇ                         AI AGENT / IDE                             ‚îÇ    ‚îÇ
‚îÇ   ‚îÇ                                                                    ‚îÇ    ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Reads CKG for situational awareness                             ‚îÇ    ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Queries CKG before making changes                               ‚îÇ    ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Performs L2 enrichment (adds business intent)                   ‚îÇ    ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Output: code_knowledge_graph_enriched_by_Agent.json             ‚îÇ    ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                       ‚îÇ consumes                            ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ   ‚îÇ                          RUNTIME                                    ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ                                                                     ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ  Orchestrates builders ‚Üí Merges ASTs ‚Üí Applies adapters ‚Üí Validates ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ                                                                     ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ  Output:                                                            ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ code_knowledge_graph_ast.json      (structure)                  ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚Ä¢ code_knowledge_graph_enriched.json (L1 semantics)               ‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                       ‚îÇ uses                                ‚îÇ
‚îÇ       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ       ‚îÇ                                                               ‚îÇ     ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ   BUILDERS     ‚îÇ    ‚îÇ    ADAPTERS      ‚îÇ    ‚îÇ    PROJECT      ‚îÇ   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ                ‚îÇ    ‚îÇ                  ‚îÇ    ‚îÇ                 ‚îÇ   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  Language      ‚îÇ    ‚îÇ  Framework       ‚îÇ    ‚îÇ  Configuration  ‚îÇ   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  Observers     ‚îÇ    ‚îÇ  Interpreters    ‚îÇ    ‚îÇ  Only           ‚îÇ   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ                ‚îÇ    ‚îÇ                  ‚îÇ    ‚îÇ                 ‚îÇ   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Python ‚úÖ   ‚îÇ    ‚îÇ  ‚Ä¢ Django ‚úÖ     ‚îÇ    ‚îÇ  ‚Ä¢ profile.json ‚îÇ   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ HTML ‚úÖ     ‚îÇ    ‚îÇ  ‚Ä¢ FastAPI ‚úÖ    ‚îÇ    ‚îÇ                 ‚îÇ   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ CSS ‚úÖ      ‚îÇ    ‚îÇ  ‚Ä¢ HTMX ‚úÖ       ‚îÇ    ‚îÇ                 ‚îÇ   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ (Future)    ‚îÇ    ‚îÇ  ‚Ä¢ (Future)      ‚îÇ    ‚îÇ                 ‚îÇ   ‚îÇ     ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ     ‚îÇ
‚îÇ           ‚îÇ                      ‚îÇ                       ‚îÇ            ‚îÇ     ‚îÇ
‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ     ‚îÇ
‚îÇ                                  ‚îÇ governed by                        ‚îÇ     ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ     ‚îÇ
‚îÇ                    ‚îÇ           CORE            ‚îÇ                      ‚îÇ     ‚îÇ
‚îÇ                    ‚îÇ  software_schema/         ‚îÇ                      ‚îÇ     ‚îÇ
‚îÇ                    ‚îÇ  ‚Ä¢ nodes.json (vocabulary)‚îÇ                      ‚îÇ     ‚îÇ
‚îÇ                    ‚îÇ  ‚Ä¢ edges.json (relations) ‚îÇ                      ‚îÇ     ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 4. Layer 1: Core (Universal Laws)

The Core layer defines the **complete vocabulary** that Spashta uses to describe software.

### 4.1 Core Schema (`core/software_schema/`)

| File | Purpose | Status |
|------|---------|--------|
| `nodes.json` | Defines WHAT can exist (nouns) | üîí FROZEN |
| `edges.json` | Defines HOW things relate (verbs) | üîí FROZEN |

#### nodes.json ‚Äî Universal Node Types

These are the fundamental software building blocks:

| Node Type | Description | Languages That Use It |
|-----------|-------------|----------------------|
| `File` | A source code file | All |
| `Function` | A callable unit of logic | Python, JS, C, Go |
| `Class` | An object-oriented container | Python, Java, JS |
| `Method` | A function inside a class | Python, Java |
| `Variable` | A named data holder | All |
| `Template` | A presentation layer file | HTML, Jinja |
| `Route` | An HTTP endpoint | Django, FastAPI |
| `StaticAsset` | CSS, JS, or image files | HTML |
| `DataModel` | A persistent data structure | Django ORM, SQLModel |

> **Key Insight**: The schema defines what *can* exist, never what *must* exist.

#### edges.json ‚Äî Universal Relationship Types

| Edge Type | Meaning | Example |
|-----------|---------|---------|
| `calls` | Function invokes another | `view_user()` ‚Üí `get_user()` |
| `imports` | File imports a module | `views.py` ‚Üí `models` |
| `contains` | Parent contains child | `File` ‚Üí `Function` |
| `renders_template` | Python renders HTML | `view()` ‚Üí `template.html` |
| `links_static_asset` | HTML links CSS/JS | `base.html` ‚Üí `style.css` |
| `inherits` | Class extends another | `UserView` ‚Üí `View` |

---

## 5. Layer 2: Builders (Language Observers)

Builders are responsible for **extracting structure** from source code.

### 5.1 Builder Philosophy

> **Builders are cameras. They observe and record, never interpret.**

| Builders DO | Builders DO NOT |
|-------------|-----------------|
| Extract functions, classes, imports | Guess intent or meaning |
| Track line numbers and docstrings | Apply framework rules |
| Emit nodes/edges per Core schema | Infer business logic |
| Log ambiguities for unknown patterns | Auto-fix or repair code |

### 5.2 Current Builders

| Language | Builder | Status |
|----------|---------|--------|
| Python | `builders/python/build_python_ast.py` | ‚úÖ Active |
| HTML | `builders/html/build_html_ast.py` | ‚úÖ Active |
| CSS | `builders/css/build_css_ast.py` | ‚úÖ Active |
| JavaScript | `builders/javascript/` | üîú Future |
| Java | `builders/java/` | üîú Future |

### 5.3 Language Mapping

Each builder has a `language_mapping.json` that defines how language syntax maps to Core concepts:

**Python Example:**
```json
{
  "FunctionDef": "Function",
  "ClassDef": "Class",
  "Import": "imports"
}
```

**Builder Flow:**
```
Python syntax (def foo():)
    ‚Üí AST parsing
    ‚Üí Consult language_mapping.json
    ‚Üí Emit Core-shaped node: { "type": "Function", "name": "foo" }
```

### 5.4 Builder Output

Each builder produces a **fragment** that is later merged:

| File | Location |
|------|----------|
| `fragment_python.json` | `runtime/builders_generated_fragments/` |
| `fragment_html.json` | `runtime/builders_generated_fragments/` |
| `fragment_css.json` | `runtime/builders_generated_fragments/` |

### 5.5 Builder Instruction JSONs (For Contributors)

To ensure consistency and strictness when developing new builders, each language has a **builder instruction JSON** file:

| Language | Instruction File |
|----------|------------------|
| Python | `builders/python/builder_python_instructions_for_builder_code_development.json` |
| HTML | `builders/html/builder_html_instructions_for_builder_code_development.json` |
| CSS | `builders/css/builder_css_instructions_for_builder_code_development.json` |

**Purpose**: These files define strict guidelines for builder script development:
- What the builder MUST extract
- What the builder MUST NOT do
- How to handle ambiguities
- Output format requirements

**For Contributors Adding New Languages (e.g., Java):**
1. Create `builders/java/builder_java_instructions_for_builder_code_development.json`
2. Create `builders/java/java_language_mapping.json` (must align with Core schema)
3. Provide both files to the AI agent when developing the builder script
4. The agent will use these as strict contracts for implementation

### 5.6 Language Mapping Preparation Guide

When creating a `language_mapping.json` for a new language, follow these rules:

#### Must Align with Core Schema

Every mapping must reference node types and edge types that exist in:
- `core/software_schema/nodes.json`
- `core/software_schema/edges.json`

**Valid mapping:**
```json
{
  "FunctionDef": "Function",
  "ClassDef": "Class",
  "Import": "imports"
}
```

**Invalid mapping (node type doesn't exist in Core):**
```json
{
  "FunctionDef": "Procedure"  
}
```

#### Mapping Rules

| Rule | Description |
|------|-------------|
| **Use Core vocabulary only** | Never invent new node/edge types |
| **Map syntax, not semantics** | `def foo():` ‚Üí Function, not "Controller" |
| **One-to-one mapping** | Each syntax construct maps to exactly one Core concept |
| **Document unknowns** | If a construct has no Core equivalent, log as ambiguity |

#### Recommended Process

1. **Study Core schema first** ‚Äî Know what nodes/edges exist
2. **List language constructs** ‚Äî All syntax elements to map
3. **Create draft mapping** ‚Äî Map each construct to Core
4. **Validate against schema** ‚Äî Ensure all targets exist
5. **Test with sample code** ‚Äî Run builder on real examples

---

## 6. Layer 3: Adapters (Framework Interpreters)

Adapters add **framework-specific meaning** on top of structure.

### 6.1 Adapter Philosophy

> **Adapters add meaning, never modify structure.**

| Adapters DO | Adapters DO NOT |
|-------------|-----------------|
| Add semantic roles (View, DataModel) | Change node types or IDs |
| Detect framework patterns | Execute code |
| Enable framework-aware queries | Modify the AST |

### 6.2 Current Adapters

| Framework | Location | Status |
|-----------|----------|--------|
| Django | `adapters/django/framework_mapping.json` | ‚úÖ Active |
| FastAPI | `adapters/fastapi/framework_mapping.json` | ‚úÖ Active |
| HTMX | `adapters/htmx/framework_mapping.json` | ‚úÖ Active |
| Flask | `adapters/flask/` | üîú Future |
| React | `adapters/react/` | üîú Future |

### 6.3 Framework Mapping

Each adapter contains `framework_mapping.json` that defines detection rules:

**Django Example:**
```json
{
  "mappings": [
    {
      "node_type": "Function",
      "semantic_role": "View",
      "detection": {
        "has_argument": "request",
        "calls": ["render", "redirect", "HttpResponse"]
      }
    },
    {
      "node_type": "Class",
      "semantic_role": "DataModel",
      "detection": {
        "inherits": "models.Model"
      }
    }
  ]
}
```

### 6.4 Two-Stage Transformation

```
Stage 1 (Builder):    Python def ‚Üí Core "Function" node
Stage 2 (Adapter):    Function + request arg + render() ‚Üí semantic_role: "View"
```

The original node is **never replaced**, only **annotated**.

---

## 7. Layer 4: Runtime (Execution Engine)

Runtime orchestrates builders and adapters to produce the final CKG.

### 7.1 Runtime Scripts

| Script | Purpose | Output |
|--------|---------|--------|
| `build_runtime_ast.py` | Run all builders, merge outputs | `code_knowledge_graph_ast.json` |
| `enrich_runtime_ast.py` | Apply adapter semantic roles | `code_knowledge_graph_enriched.json` |
| `validate_ast_equivalence.py` | Ensure structure unchanged | Pass/Fail |
| `diff_runtime_ast.py` | Detect changes for incremental updates | `diff_report.json` |
| `query_spashta.py` | CLI tool for querying CKG | Query results |

### 7.2 Execution Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. validate_project_profile.py    ‚îÇ  ‚Üê Validate profile.json       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  2. context_loader.py              ‚îÇ  ‚Üê Load languages, frameworks  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  3. build_runtime_ast.py           ‚îÇ  ‚Üê Run all builders            ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Builders produce fragment_*.json files                      ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Merged into code_knowledge_graph_ast.json                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  4. enrich_runtime_ast.py          ‚îÇ  ‚Üê Apply L1 adapter enrichment ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Reads framework_mapping.json for each framework             ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Adds semantic_role to matching nodes                        ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Output: code_knowledge_graph_enriched.json                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  5. validate_ast_equivalence.py    ‚îÇ  ‚Üê Verify structure preserved  ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Node count must match                                       ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Node IDs must match                                         ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Edge topology must match                                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  6. [Optional] LLM Enrichment      ‚îÇ  ‚Üê AI Agent adds L2 semantics  ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Agent reads code files                                      ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Adds business_intent, domain_tags                           ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ Output: code_knowledge_graph_enriched_by_Agent.json         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 7.3 Output Files

| File | Description | Modifiable By |
|------|-------------|---------------|
| `code_knowledge_graph_ast.json` | Raw structural AST | üîí Runtime only |
| `code_knowledge_graph_enriched.json` | L1 enriched (adapters) | üîí Runtime only |
| `code_knowledge_graph_enriched_by_Agent.json` | L2 enriched (LLM) | ‚úÖ AI Agent |

### 7.4 Query Tool (`query_spashta.py`)

The query tool is the **primary interface** for AI Agents to access the CKG.

| Command | Purpose | Example |
|---------|---------|--------|
| `search` | Find nodes by name/attributes | `search "login" --type Function --json` |
| `locate` | Get file path + line numbers | `locate "app/views.py::login" --json` |
| `read` | View actual source code | `read "app/views.py::login" --json` |
| `details` | Full node metadata | `details "app/views.py::login" --json` |
| `impact` | Who depends on this? | `impact "app/models.py::User" --depth 3 --json` |
| `dependencies` | What does this use? | `dependencies "app/views.py::login" --json` |
| `call-graph` | Function call chains (Python only) | `call-graph "app/views.py::search" --json` |
| `stats` | Graph statistics | `stats --json` |
| `list-files` | All indexed files | `list-files --json` |

**Always use `--json` for AI agent consumption.**

> For detailed documentation, see `Query_Tool_Readme.md`

---

## 8. Layer 5: Project (Declaration Layer)

The Project layer is the **activation switchboard** for a specific codebase.

### 8.1 profile.json

```json
{
  "_meta": {
    "supported_languages": ["python", "html", "css"],
    "supported_frameworks": ["django", "fastapi", "htmx"]
  },
  "project_root": "C:/path/to/your/project",
  "languages": ["python", "html", "css"],
  "frameworks": ["django", "htmx"]
}
```

| Field | Purpose |
|-------|---------|
| `project_root` | Where to scan for source code |
| `languages` | Which builders to run |
| `frameworks` | Which adapters to apply |
| `_meta.supported_*` | Reference for valid values |

### 8.2 Why Project Layer Exists

| Without Project Layer | With Project Layer |
|-----------------------|-------------------|
| Agents guess architecture | Architecture is explicit |
| Framework defaults are law | Project can override |
| Mixed-style repos confuse agents | Clear declarations |

---

## 9. Enrichment Levels

Spashta uses a **two-level enrichment model**:

### Level 1: Adapter Enrichment (Rule-Based)

| Aspect | Details |
|--------|---------|
| **Performed By** | `enrich_runtime_ast.py` (programmatic) |
| **Input** | `framework_mapping.json` detection rules |
| **Characteristics** | Deterministic, cheap, schema-validated |
| **Output** | `code_knowledge_graph_enriched.json` |

**What L1 Adds:**
- `semantic_role`: View, DataModel, Template, etc.
- Framework-specific metadata

### Level 2: LLM Enrichment (AI Agent)

| Aspect | Details |
|--------|---------|
| **Performed By** | AI Agent (prompted, not scripted) |
| **Trigger** | `Prompt_For_LLM_Enrichment.txt` |
| **Characteristics** | Context-aware, expensive, requires file reading |
| **Output** | `code_knowledge_graph_enriched_by_Agent.json` |

**What L2 Adds:**

| Field | Description |
|-------|-------------|
| `business_intent` | What the code does in business terms |
| `domain_tags` | Categories like #payments, #auth, #user-management |
| `reasoning_notes` | Why the code is structured this way |
| `resolved_ambiguities` | Dynamic calls that static analysis couldn't resolve |

---

## 10. Agent Workflow

Agents follow a **strict, repeatable workflow** to avoid hallucination and drift.

### 10.1 Before Acting

1. **Read `profile.json`** ‚Äî Know what stack is active
2. **Read CKG** ‚Äî Understand existing structure
3. **Query for context** ‚Äî Use `query_spashta.py` or direct JSON access

### 10.2 Validation Rules

Agents must validate changes against:

| Check | Purpose |
|-------|---------|
| **Structure preservation** | Enrichment didn't modify AST |
| **Impact analysis** | What breaks if I change X? |
| **Dependency check** | Does the target exist? |

### 10.3 What Agents Can/Cannot Do

| ‚úÖ Agents CAN | ‚ùå Agents CANNOT |
|--------------|------------------|
| Read all CKG files | Modify Core schema |
| Write to L2 enriched file | Modify L1 CKG files |
| Query structure | Change node types or IDs |
| Add semantic metadata | Delete nodes or edges |

---

## 11. Extensibility Guide

### 11.1 Adding a New Language

1. **Create builder directory**: `builders/your_language/`
2. **Create builder script**: `build_your_language_ast.py`
3. **Create language mapping**: `language_mapping.json`
4. **Emit Core-compliant nodes/edges**
5. **Register in `profile.json`**: Add to `_meta.supported_languages`

### 11.2 Adding a New Framework

1. **Create adapter directory**: `adapters/your_framework/`
2. **Create framework mapping**: `framework_mapping.json`
3. **Define detection rules**: Patterns that identify framework constructs
4. **Register in `profile.json`**: Add to `_meta.supported_frameworks`

### 11.3 Extensibility Rules

| Rule | Reason |
|------|--------|
| Builders must emit Core schema nodes only | Consistency across languages |
| Adapters must not modify structure | Semantic overlay only |
| New languages don't require Core changes | Universal schema |
| New frameworks don't require builder changes | Separation of concerns |

---

## 12. File Modification Rules

| File/Directory | üîí Status | Who Can Modify |
|----------------|-----------|----------------|
| `core/software_schema/*` | FROZEN | Nobody (additive only) |
| `builders/*` | Protected | Contributors (with approval) |
| `adapters/*` | Protected | Contributors (with approval) |
| `runtime/*.py` | Protected | Contributors (with approval) |
| `runtime/code_knowledge_graph_ast.json` | Generated | Runtime only |
| `runtime/code_knowledge_graph_enriched.json` | Generated | Runtime only |
| `runtime/code_knowledge_graph_enriched_by_Agent.json` | L2 Output | AI Agent |
| `project/profile.json` | Configurable | User + Agent (with confirmation) |

---

## 13. Mental Anchors

These are the core principles to remember:

| Anchor | Meaning |
|--------|---------|
| **Schema defines what CAN exist** | Not what MUST exist |
| **Builders extract facts** | Not meaning |
| **Adapters add semantics** | Not structure |
| **L1 = Cheap & deterministic** | Adapter-based enrichment |
| **L2 = Token-intensive (one-time)** | LLM-based enrichment; later only for changes/new files |
| **AST JSON = Objective truth** | Structure only |
| **Enriched JSON = Understanding** | Structure + meaning |
| **Agents query, not guess** | CKG before action |
| **Structure before semantics** | Always |
| **Silence is failure** | Ambiguity must be logged |

---

## Summary

Spashta-CKG is a **universal, deterministic protocol for agentic software understanding**.

It replaces:
- Guessing with querying
- Memory with structure
- Hallucination with validation

By separating:
- Structure from semantics (Builders vs Adapters)
- Language from framework (Language mapping vs Framework mapping)
- L1 from L2 (Rule-based vs LLM enrichment)

Spashta-CKG enables AI agents to operate **safely, predictably, and at scale** across languages, frameworks, and time.

---

## Related Documentation

| Document | Purpose |
|----------|---------|
| `README.md` | Quick start guide |
| `Query_Tool_Readme.md` | **Query tool command reference** |
| `Runtime_Readme.md` | Runtime execution details |
| `Codes_Info_Readme.md` | Python script reference |
| `Json_Info_Readme.md` | JSON configuration reference |
| `adapter_Readme.md` | Adapter creation guide |
| `Builders_Roadmap.md` | Builder capabilities and roadmap |
| `spashta_ckg_builder_script_philosophy_contributor_reference.md` | Builder contributor guidelines |
| `spashta_ckg_mapping_philosophy_contributor_reference.md` | Mapping contributor guidelines |

---

*Spashta-CKG 2.0 ‚Äî Deterministic Architectural Memory for Agentic Coding*
